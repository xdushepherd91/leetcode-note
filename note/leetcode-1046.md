### 题目

[[leetcode 1046]](https://leetcode-cn.com/problems/last-stone-weight/) 最后一块石头的重量

### 描述

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

 

提示：

1 <= stones.length <= 30
1 <= stones[i] <= 1000


### 解析

首先，来思考一下这个算法的大致实现：

1. 挑选最大的两个石头，重量相减。得到一个不小于0的重量。
2. 重新将其放入已经排序的石头队列中。
3. 重新挑选两个最大的石头，重复操作。

我们这里很容易想到的是，使用优先队列，每次拿两个，操作，再放入优先队列，循环，直到队列大小为1或者为0.结束。

下面的实现是一个不使用优先队列的方法：

首先，根据提示知道石头的重量不超过1000，我们可以选择使用桶排序。每次两块石头重量相减得到的石头再次进入桶中即可。

1. 对石头进行桶排序。
2. 在一个大循环中，循环进行销毁操作，直到无法选出第二块石头为止。
2. 在一个循环中，先挑选最重的一个石头出来，令其对应下标减1。
3. 在另一个循环中，再挑选不重于第一个石头的另一个石头，令其对应下标减1。
4. 将两个石头重量相减，在结果的对应下标出加1。
5. 一轮销毁操作结束。准备开始下一轮操作，在开始之前，我们要记录一些数据。
   1. 当前最重石头的下标。挑选第一块石头时的下标即可。
   2. 令记录石头重量的first和second变量为0。这一点很重要。因为如果某一次
      second在挑选过后依然未0，说明只剩下不超过一块石头了。而first置为0，可以保证在大循环退出时，fisrt记录的是剩下的一块石头的重量或者为0，而不是一个大于0的错误数字。

大循环退出条件： 某次挑选过后，second==0。说明无法拿到第二块石头了。



### 实现

```java
class Solution {
    public int lastStoneWeight(int[] stones) {
        int[] ss = new int[1001];
        for(int stone: stones){
            ss[stone]++;
        }
        int h=1000,first=0,second=0;
        while(true){
            while(h>0){
                if(ss[h]>0){
                    first=h;
                    ss[h]--;
                    break;
                }
                h--;
            }
            int temp = h;
            while(h>0){
                if(ss[h]>0){
                    second=h;
                    ss[h]--;
                    break;
                }
                h--;
            }
            if(second==0)break;
            ss[first-second] +=1;
            h=temp;
            first=0;
            second=0;
        }
        return first;
    }
}
```